{
  "name": "backbrace",
  "version": "0.0.0",
  "author": {
    "name": "Patrick Williams",
    "email": "patrick@bittorrent.com"
  },
  "main": "./backbrace.min.js",
  "dependencies": {
    "underscore": "~1.3.1",
    "backbone": "~0.9.2"
  },
  "gitHead": "bfc1e1a3472f4bf4aa13cddfb76cb8e9dde90a28",
  "readme": "[![Build Status](https://secure.travis-ci.org/bittorrenttorque/backbrace.png?branch=master)](https://travis-ci.org/bittorrenttorque/backbrace)\n\n# Backbrace.js\n\n## Why?\nTaller [Backbone](https://github.com/documentcloud/backbone) data sets tend to slouch. Let them stand tall and proud, by allowing for jQueryesque *.live()* calls.\n## How?\n```html\n<!-- Make sure the dependencies are loaded before backbrace -->\n<script type=\"text/javascript\" src=\"underscore.js\"></script>\n<script type=\"text/javascript\" src=\"backbone.js\"></script>\n<script type=\"text/javascript\" src=\"backbrace.js\"></script>\n```\nThe first argument is a space deliminated string of attribute keys in models, or model ids in collections. The callback will be called when there is a new instance of the final matching selector.\n```js\nvar model = new Backbone.Model;\nmodel.live('a b c d', function(d) {\n});\n\nmodel.set('a', new Backbone.Collection);\nmodel.get('a').add(new Backbone.Model({id: 'b'}));\nmodel.get('a').get('b').set('c', new Backbone.Collection);\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'd'}));\n\n//Your callback was just called!\n```\n## Regex?\nAlmost. * is supported.  \n__For example:__\n```js\nvar model = new Backbone.Model;\nmodel.live('a * c *', function(e) {\n});\n\nmodel.set('a', new Backbone.Collection);\nmodel.get('a').add(new Backbone.Model({id: 'b'}));\nmodel.get('a').get('b').set('c', new Backbone.Collection);\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'd'}));\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'e'}));\nmodel.get('a').get('b').get('c').add(new Backbone.Model({id: 'f'}));\n\n//Your callback was just called...three times!\n```\n__or for a much less contrived example:__\n```js\nvar collection = new Backbone.Collection;\ncollection.live('* name', function(name) {\n  console.log('Someone has the name: ' + name);\n});\n\ncollection.add(new Backbone.Model({name: 'Daniel'}));\ncollection.add(new Backbone.Model({name: 'Robert'}));\ncollection.add(new Backbone.Model({name: 'Mary'}));\n\n//The following works too!\nvar person = new Backbone.Model;\ncollection.add(person);\nperson.set('name', 'Patrick');\n```\n## When?\nThis is probably not useful if your collections just mirror flat database tables. However, if you are using something like [BitTorrent's btapp library](http://github.com/pwmckenna/btapp/), it tends to be a struggle to cleanly interact with a tree of Backbone models and collections that grows to be quite deep. In most cases, you're only interested in the leaves of the tree, and this is an attempt to simplify that experience.  \n\n\nTo borrow an example from the [aforementioned btapp library](http://github.com/pwmckenna/btapp/), imagine a root object, that has a collection of torrents, which each contain a list of files, which have a properties attribute, which itself is chocked full of key value pairs. If we wanted a simple way to create a Backbone.View for each of these files' properties objects, we might do the following:\n```js\nvar btapp = new Btapp;\nbtapp.live('torrent * file * properties', function(properties) {\n  var view = new FilePropertiesView({model: properties});\n  $('#files').append(view.render().el);\n});\n```\n\n## Callback arguments\nEvery value that matches the filter is passed as an argument, in reverse order. In most cases its just the last value that you'd be interested in, but sometimes its nice to know where you came from.\n\n```js\nvar families = new Backbone.Collection;\nvar family = new Backbone.Model({id: 'Marrah/Williams'});\nvar members = new Backbone.Collection;\n\nmembers.add(new Backbone.Model({name: 'Daniel'}));\nmembers.add(new Backbone.Model({name: 'Robert'}));\nmembers.add(new Backbone.Model({name: 'Mary'}));\nmembers.add(new Backbone.Model({name: 'Patrick'}));\nfamily.set({members: members});\nfamilies.add(family);\n\nfamilies.live('* members * name', function(name, member, members, family) {\n  //what to do with all this info?!\n});\n```\n## Die\nThe *die* function is to *live*, what *off* is to *on*. Call it with the same selector, callback, and context, and your callback won't be called again.\n```js\nvar model = new Backbone.Model;\nvar cb = function(x, a) {};\nmodel.live('a *', cb, this);\n\nmodel.set('a', new Backbone.Collection);\nmodel.get('a').add(new Backbone.Model({id: 'b'}));\n//callback called\nmodel.die('a b', cb, this);\nmodel.get('a').add(new Backbone.Model({id: 'c'}));\n//callback not called\n```\n\n## Delimiter\nBy default, model id/attribute keys are seperated by spaces. Unfortunately those can legally exist in those\nvariables, so to split up your tokens by a custom delimiter (that you hopefully are sure does not exist in your model ids or attribute keys), use the following functionality.\n```js\nBackbrace.setDelimiter('@');\n```\n__Note:__ You must call this before using live/die to avoid unpredictable behavior. You can also technically do this after making all the corresponding die calls, but this is error prone and not advised.  \n__Forbidden Values:__ ',' and the character set as your wildcard (by default '*')\n\n## Wildcard\nThe wildcard (*) suffers from the same problem as the delimiter, in that it can be a valid model id or attribute key.\n```js\nBackbrace.setWildcard('%');\n```\n\n__Note:__ You must call this before using live/die to avoid unpredictable behavior. You can also technically do this after making all the corresponding die calls, but this is error prone and not advised.  \n__Forbidden Values:__ ',' and the character set as your delimiter (by default ' ')\n\n## Todo\n- Support idAttribute\n- Support id changes\n- Look into complicated partial tree detatches, then re-adding\n\n## Feedback\nI'd love feedback. [@pwmckenna](https://twitter.com/#!/pwmckenna)\n\n##License\nCopyright 2012 Patrick Williams, BitTorrent Inc.  \nhttp://torque.bittorrent.com/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n<br><br>\nSpecial thanks to Andrew de Andrade ([@andrewdeandrade](https://twitter.com/#!/andrewdeandrade)) for the inspiration!\n",
  "readmeFilename": "README.md",
  "_id": "backbrace@0.2.0",
  "description": "[![Build Status](https://secure.travis-ci.org/bittorrenttorque/backbrace.png?branch=master)](https://travis-ci.org/bittorrenttorque/backbrace)",
  "commit": "bfc1e1a3472f4bf4aa13cddfb76cb8e9dde90a28",
  "repository": {
    "type": "git",
    "url": "git://github.com/bittorrenttorque/backbrace"
  }
}